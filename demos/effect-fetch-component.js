// Generated by HTMS - ESM format
'use strict';

class EffectFetchDemoComponent extends HTMLElement {
  static get __htmsTemplate() {
    if (!this.__templateCache) {
      const template = document.createElement('template');
      template.innerHTML = '<div class="demo"><button id="load">Load Quote</button><p id="status">Status: Idle</p><blockquote id="quote"></blockquote><p id="error" class="error"></p></div>';
      this.__templateCache = template;
    }
    return this.__templateCache;
  }
  __htmsResolvePath(path) {
    if (!Array.isArray(path) || path.length === 0) {
      throw new Error('Invalid state path');
    }
    let ref = this;
    for (let i = 0; i < path.length - 1; i++) {
      const key = path[i];
      const next = ref[key];
      if (next === undefined || next === null || typeof next !== 'object') {
        ref[key] = {};
      }
      ref = ref[key];
    }
    return {
      target: ref,
      key: path[path.length - 1]
    };
  }
  __htmsInitState(path, initializer) {
    const {target, key} = this.__htmsResolvePath(path);
    if (!Object.prototype.hasOwnProperty.call(target, key)) {
      target[key] = initializer();
    }
  }
  __htmsSetState(path, op, valueFactory) {
    const {target, key} = this.__htmsResolvePath(path);
    if (op === '++') {
      const current = typeof target[key] === 'number' ? target[key] : 0;
      target[key] = current + 1;
      return;
    }
    if (op === '--') {
      const current = typeof target[key] === 'number' ? target[key] : 0;
      target[key] = current - 1;
      return;
    }
    const current = target[key];
    const value = valueFactory();
    switch (op) {
    case '+=':
      target[key] = (typeof current === 'number' ? current : 0) + value;
      break;
    case '-=':
      target[key] = (typeof current === 'number' ? current : 0) - value;
      break;
    case '*=':
      target[key] = (typeof current === 'number' ? current : 0) * value;
      break;
    case '/=':
      target[key] = (typeof current === 'number' ? current : 0) / value;
      break;
    default:
      target[key] = value;
    }
  }
  __htmsEnsureArray(path) {
    const {target, key} = this.__htmsResolvePath(path);
    if (!Array.isArray(target[key])) {
      target[key] = [];
    }
    return target[key];
  }
  __htmsPushState(path, valueFactory) {
    const arr = this.__htmsEnsureArray(path);
    arr.push(valueFactory());
  }
  __htmsSpliceState(path, indexFactory, deleteFactory, valuesFactory) {
    const arr = this.__htmsEnsureArray(path);
    const index = indexFactory();
    const del = deleteFactory();
    const values = valuesFactory();
    arr.splice(index, del, ...values);
  }
  constructor() {
    super();
    this.__htmsRoot = null;
    if (!this.__htmsRoot) {
      this.__htmsRoot = this.attachShadow({ mode: 'open' });
    }
  }
  connectedCallback() {
    this.render();
  }
  render() {
    const root = this.__htmsRoot || this;
    if (!root) {
      throw new Error('Component root not initialized');
    }
    const componentRoot = root;
    while (componentRoot.firstChild) {
      componentRoot.removeChild(componentRoot.firstChild);
    }
    const staticFragment = EffectFetchDemoComponent.__htmsTemplate.content.cloneNode(true);
    componentRoot.appendChild(staticFragment);
    this.__htmsInitState(['state'], () => {
    });
    {
      const eventTargets = componentRoot.querySelectorAll('#load');
      eventTargets.forEach(targetEl => {
        const _handler0 = event => {
          // No event body
          this.__htmsSetState([
            'state',
            'loadNonce'
          ], '=', () => Date.now());
          this.render();
        };
        targetEl.addEventListener('click', _handler0);
      });
    }
    (function () {
      if (typeof window === 'undefined')
        return;
      if (!window.__htms) {
        const runtime = {
          watchers: [],
          effects: [],
          flushScheduled: false,
          scheduleFlush: function () {
            if (this.flushScheduled) {
              return;
            }
            this.flushScheduled = true;
            const runFlush = () => {
              this.flushScheduled = false;
              try {
                this.flush();
              } catch (error) {
                console.error('HTMS runtime flush failed:', error);
              }
            };
            if (typeof queueMicrotask === 'function') {
              queueMicrotask(runFlush);
            } else {
              Promise.resolve().then(runFlush);
            }
          },
          flush: function () {
            this.watchers = this.watchers.filter(function (watcher) {
              if (watcher.disposed) {
                return false;
              }
              try {
                const el = document.querySelector(watcher.sel);
                if (!el) {
                  if (watcher.autoDispose) {
                    watcher.disposed = true;
                    return false;
                  }
                  return true;
                }
                el[watcher.prop] = watcher.fn();
              } catch (error) {
                console.error('HTMS watcher update failed:', error);
              }
              return !watcher.disposed;
            });
            this.effects = this.effects.filter(effect => {
              if (effect.disposed) {
                return false;
              }
              if (effect.owner && !effect.owner.isConnected) {
                effect.dispose();
                return false;
              }
              const values = [];
              let shouldRun = effect.dirty || effect.depsFns.length === 0;
              for (let i = 0; i < effect.depsFns.length; i++) {
                let value;
                try {
                  value = effect.depsFns[i]();
                } catch (error) {
                  console.error('HTMS effect dependency failed:', error);
                  value = undefined;
                }
                values.push(value);
                if (!shouldRun && (i >= effect.lastValues.length || effect.lastValues[i] !== value)) {
                  shouldRun = true;
                }
              }
              effect.lastValues = values;
              if (effect.skipInitial && !effect.initialized) {
                effect.skipInitial = false;
                effect.dirty = false;
                effect.initialized = true;
                return !effect.disposed;
              }
              if (shouldRun) {
                effect.dirty = false;
                effect.execute();
                effect.initialized = true;
                if (effect.once) {
                  effect.dispose();
                  return false;
                }
              }
              return !effect.disposed;
            });
          },
          bind: function (sel, prop, fn) {
            const watcher = {
              sel,
              prop,
              fn,
              disposed: false,
              autoDispose: true
            };
            this.watchers.push(watcher);
            try {
              const el = document.querySelector(sel);
              if (!el) {
                console.warn('BIND target not found:', sel);
              } else {
                el[prop] = fn();
              }
            } catch (error) {
              console.error('BIND compute failed:', error);
            }
            return () => {
              watcher.disposed = true;
            };
          },
          notify: function () {
            this.scheduleFlush();
          },
          registerEffect: function (spec) {
            if (!spec || !spec.id) {
              console.error('HTMS effect requires an id');
              return {
                dispose: function () {
                }
              };
            }
            const owner = spec.owner || null;
            const deps = Array.isArray(spec.deps) ? spec.deps.filter(fn => typeof fn === 'function') : [];
            let record = this.effects.find(effect => effect.owner === owner && effect.id === spec.id);
            if (!record) {
              record = {
                owner,
                id: spec.id,
                depsFns: deps,
                run: typeof spec.run === 'function' ? spec.run : function () {
                },
                cleanupFactory: typeof spec.cleanup === 'function' ? spec.cleanup : undefined,
                cleanup: undefined,
                lastValues: [],
                disposed: false,
                dirty: spec.immediate !== false,
                once: !!spec.once,
                initialized: false,
                skipInitial: spec.immediate === false,
                dispose: function () {
                  if (record.disposed) {
                    return;
                  }
                  record.disposed = true;
                  if (typeof record.cleanup === 'function') {
                    try {
                      record.cleanup();
                    } catch (error) {
                      console.error('HTMS effect cleanup failed:', error);
                    }
                  }
                  record.cleanup = undefined;
                  record.initialized = false;
                  record.skipInitial = false;
                },
                execute: function () {
                  if (record.disposed) {
                    return;
                  }
                  if (typeof record.cleanup === 'function') {
                    try {
                      record.cleanup();
                    } catch (error) {
                      console.error('HTMS effect cleanup failed:', error);
                    }
                    record.cleanup = undefined;
                  }
                  let nextCleanup = record.cleanupFactory;
                  try {
                    const result = record.run();
                    if (result && typeof result.then === 'function') {
                      record.initialized = true;
                      result.then(resolved => {
                        if (typeof resolved === 'function') {
                          record.cleanup = resolved;
                        } else if (typeof nextCleanup === 'function') {
                          record.cleanup = nextCleanup;
                        }
                      }).catch(error => {
                        console.error('HTMS effect promise rejected:', error);
                      });
                      return;
                    }
                    if (typeof result === 'function') {
                      nextCleanup = result;
                    }
                  } catch (error) {
                    console.error('HTMS effect execution failed:', error);
                  }
                  record.cleanup = typeof nextCleanup === 'function' ? nextCleanup : undefined;
                  record.initialized = true;
                }
              };
              this.effects.push(record);
            } else {
              record.depsFns = deps;
              record.run = typeof spec.run === 'function' ? spec.run : record.run;
              record.cleanupFactory = typeof spec.cleanup === 'function' ? spec.cleanup : record.cleanupFactory;
              record.once = !!spec.once;
              record.disposed = false;
              if (spec.immediate !== false && !record.initialized) {
                record.dirty = true;
              }
              if (spec.immediate === false && !record.initialized) {
                record.skipInitial = true;
              } else if (spec.immediate !== false) {
                record.skipInitial = false;
              }
            }
            this.scheduleFlush();
            return {
              dispose: function () {
                record.dispose();
              }
            };
          },
          keyedList: function (sel, arr, render, keyFn) {
            const container = document.querySelector(sel);
            if (!container) {
              console.warn('KEYEDLIST target not found:', sel);
              return;
            }
            const existing = new Map();
            Array.from(container.children).forEach(function (node) {
              if (node && typeof node.getAttribute === 'function') {
                const key = node.getAttribute('data-key');
                if (key != null) {
                  existing.set(key, node);
                }
              }
            });
            const used = new Set();
            for (let i = 0; i < arr.length; i++) {
              const item = arr[i];
              const key = String(keyFn(item, i));
              let node = existing.get(key);
              if (!node) {
                node = render(item, i);
                if (node && typeof node.setAttribute === 'function') {
                  node.setAttribute('data-key', key);
                }
              }
              if (node) {
                container.appendChild(node);
                used.add(key);
              }
            }
            existing.forEach(function (node, key) {
              if (!used.has(key) && node && node.parentNode === container) {
                container.removeChild(node);
              }
            });
          },
          disposeEffectsFor: function (owner) {
            if (!owner) {
              return;
            }
            this.effects = this.effects.filter(effect => {
              if (effect.owner === owner) {
                effect.dispose();
                return false;
              }
              return true;
            });
          }
        };
        Object.defineProperty(window, '__htms', {
          value: runtime,
          configurable: false,
          enumerable: false,
          writable: false
        });
      }
    }());
    (function (owner) {
      var runtime = typeof window !== 'undefined' ? window.__htms : null;
      if (!runtime) {
        return;
      }
      runtime.registerEffect({
        owner: owner,
        id: '__effect_1',
        deps: [
          function () {
            return owner && owner.state && owner.state.loading;
          },
          function () {
            return owner && owner.state && owner.state.quote;
          },
          function () {
            return owner && owner.state && owner.state.error;
          }
        ],
        immediate: true,
        once: false,
        run: function () {
          try {
            const host = owner;
            if (!host || !host.__htmsRoot) {
              return;
            }
            const root = host.__htmsRoot;
            const state = host.state || {};
            const statusEl = root.querySelector('#status');
            const quoteEl = root.querySelector('#quote');
            const errorEl = root.querySelector('#error');
            if (statusEl) {
              if (state.loading) {
                statusEl.textContent = 'Status: Loading...';
              } else if (state.error) {
                statusEl.textContent = 'Status: Error';
              } else if (state.quote) {
                statusEl.textContent = 'Status: Loaded';
              } else {
                statusEl.textContent = 'Status: Idle';
              }
            }
            if (quoteEl) {
              quoteEl.textContent = state.quote ? state.quote.text : '';
            }
            if (errorEl) {
              errorEl.textContent = state.error || '';
            }
          } catch (error) {
            console.error('EFFECT run failed:', error);
          }
        }
      });
    }(this));
    (function () {
      if (typeof window === 'undefined')
        return;
      if (!window.__htms) {
        const runtime = {
          watchers: [],
          effects: [],
          flushScheduled: false,
          scheduleFlush: function () {
            if (this.flushScheduled) {
              return;
            }
            this.flushScheduled = true;
            const runFlush = () => {
              this.flushScheduled = false;
              try {
                this.flush();
              } catch (error) {
                console.error('HTMS runtime flush failed:', error);
              }
            };
            if (typeof queueMicrotask === 'function') {
              queueMicrotask(runFlush);
            } else {
              Promise.resolve().then(runFlush);
            }
          },
          flush: function () {
            this.watchers = this.watchers.filter(function (watcher) {
              if (watcher.disposed) {
                return false;
              }
              try {
                const el = document.querySelector(watcher.sel);
                if (!el) {
                  if (watcher.autoDispose) {
                    watcher.disposed = true;
                    return false;
                  }
                  return true;
                }
                el[watcher.prop] = watcher.fn();
              } catch (error) {
                console.error('HTMS watcher update failed:', error);
              }
              return !watcher.disposed;
            });
            this.effects = this.effects.filter(effect => {
              if (effect.disposed) {
                return false;
              }
              if (effect.owner && !effect.owner.isConnected) {
                effect.dispose();
                return false;
              }
              const values = [];
              let shouldRun = effect.dirty || effect.depsFns.length === 0;
              for (let i = 0; i < effect.depsFns.length; i++) {
                let value;
                try {
                  value = effect.depsFns[i]();
                } catch (error) {
                  console.error('HTMS effect dependency failed:', error);
                  value = undefined;
                }
                values.push(value);
                if (!shouldRun && (i >= effect.lastValues.length || effect.lastValues[i] !== value)) {
                  shouldRun = true;
                }
              }
              effect.lastValues = values;
              if (effect.skipInitial && !effect.initialized) {
                effect.skipInitial = false;
                effect.dirty = false;
                effect.initialized = true;
                return !effect.disposed;
              }
              if (shouldRun) {
                effect.dirty = false;
                effect.execute();
                effect.initialized = true;
                if (effect.once) {
                  effect.dispose();
                  return false;
                }
              }
              return !effect.disposed;
            });
          },
          bind: function (sel, prop, fn) {
            const watcher = {
              sel,
              prop,
              fn,
              disposed: false,
              autoDispose: true
            };
            this.watchers.push(watcher);
            try {
              const el = document.querySelector(sel);
              if (!el) {
                console.warn('BIND target not found:', sel);
              } else {
                el[prop] = fn();
              }
            } catch (error) {
              console.error('BIND compute failed:', error);
            }
            return () => {
              watcher.disposed = true;
            };
          },
          notify: function () {
            this.scheduleFlush();
          },
          registerEffect: function (spec) {
            if (!spec || !spec.id) {
              console.error('HTMS effect requires an id');
              return {
                dispose: function () {
                }
              };
            }
            const owner = spec.owner || null;
            const deps = Array.isArray(spec.deps) ? spec.deps.filter(fn => typeof fn === 'function') : [];
            let record = this.effects.find(effect => effect.owner === owner && effect.id === spec.id);
            if (!record) {
              record = {
                owner,
                id: spec.id,
                depsFns: deps,
                run: typeof spec.run === 'function' ? spec.run : function () {
                },
                cleanupFactory: typeof spec.cleanup === 'function' ? spec.cleanup : undefined,
                cleanup: undefined,
                lastValues: [],
                disposed: false,
                dirty: spec.immediate !== false,
                once: !!spec.once,
                initialized: false,
                skipInitial: spec.immediate === false,
                dispose: function () {
                  if (record.disposed) {
                    return;
                  }
                  record.disposed = true;
                  if (typeof record.cleanup === 'function') {
                    try {
                      record.cleanup();
                    } catch (error) {
                      console.error('HTMS effect cleanup failed:', error);
                    }
                  }
                  record.cleanup = undefined;
                  record.initialized = false;
                  record.skipInitial = false;
                },
                execute: function () {
                  if (record.disposed) {
                    return;
                  }
                  if (typeof record.cleanup === 'function') {
                    try {
                      record.cleanup();
                    } catch (error) {
                      console.error('HTMS effect cleanup failed:', error);
                    }
                    record.cleanup = undefined;
                  }
                  let nextCleanup = record.cleanupFactory;
                  try {
                    const result = record.run();
                    if (result && typeof result.then === 'function') {
                      record.initialized = true;
                      result.then(resolved => {
                        if (typeof resolved === 'function') {
                          record.cleanup = resolved;
                        } else if (typeof nextCleanup === 'function') {
                          record.cleanup = nextCleanup;
                        }
                      }).catch(error => {
                        console.error('HTMS effect promise rejected:', error);
                      });
                      return;
                    }
                    if (typeof result === 'function') {
                      nextCleanup = result;
                    }
                  } catch (error) {
                    console.error('HTMS effect execution failed:', error);
                  }
                  record.cleanup = typeof nextCleanup === 'function' ? nextCleanup : undefined;
                  record.initialized = true;
                }
              };
              this.effects.push(record);
            } else {
              record.depsFns = deps;
              record.run = typeof spec.run === 'function' ? spec.run : record.run;
              record.cleanupFactory = typeof spec.cleanup === 'function' ? spec.cleanup : record.cleanupFactory;
              record.once = !!spec.once;
              record.disposed = false;
              if (spec.immediate !== false && !record.initialized) {
                record.dirty = true;
              }
              if (spec.immediate === false && !record.initialized) {
                record.skipInitial = true;
              } else if (spec.immediate !== false) {
                record.skipInitial = false;
              }
            }
            this.scheduleFlush();
            return {
              dispose: function () {
                record.dispose();
              }
            };
          },
          keyedList: function (sel, arr, render, keyFn) {
            const container = document.querySelector(sel);
            if (!container) {
              console.warn('KEYEDLIST target not found:', sel);
              return;
            }
            const existing = new Map();
            Array.from(container.children).forEach(function (node) {
              if (node && typeof node.getAttribute === 'function') {
                const key = node.getAttribute('data-key');
                if (key != null) {
                  existing.set(key, node);
                }
              }
            });
            const used = new Set();
            for (let i = 0; i < arr.length; i++) {
              const item = arr[i];
              const key = String(keyFn(item, i));
              let node = existing.get(key);
              if (!node) {
                node = render(item, i);
                if (node && typeof node.setAttribute === 'function') {
                  node.setAttribute('data-key', key);
                }
              }
              if (node) {
                container.appendChild(node);
                used.add(key);
              }
            }
            existing.forEach(function (node, key) {
              if (!used.has(key) && node && node.parentNode === container) {
                container.removeChild(node);
              }
            });
          },
          disposeEffectsFor: function (owner) {
            if (!owner) {
              return;
            }
            this.effects = this.effects.filter(effect => {
              if (effect.owner === owner) {
                effect.dispose();
                return false;
              }
              return true;
            });
          }
        };
        Object.defineProperty(window, '__htms', {
          value: runtime,
          configurable: false,
          enumerable: false,
          writable: false
        });
      }
    }());
    (function (owner) {
      var runtime = typeof window !== 'undefined' ? window.__htms : null;
      if (!runtime) {
        return;
      }
      runtime.registerEffect({
        owner: owner,
        id: '__fetch_1',
        deps: [
          function () {
            return 'https://example.com/demo-quote.json';
          },
          function () {
            return Boolean(owner && owner.state && owner.state.loadNonce);
          },
          function () {
            return owner && owner.state && owner.state.loadNonce;
          }
        ],
        immediate: false,
        once: false,
        run: function () {
          var shouldRun = Boolean(owner && owner.state && owner.state.loadNonce);
          if (!shouldRun) {
            return function () {
            };
          }
          var controller = typeof AbortController === 'function' ? new AbortController() : null;
          if (!owner) {
            return;
          }
          var target = owner;
          if (target['state'] == null || typeof target['state'] !== 'object') {
            target['state'] = {};
          }
          target = target['state'];
          target['loading'] = true;
          if (!owner) {
            return;
          }
          var target = owner;
          if (target['state'] == null || typeof target['state'] !== 'object') {
            target['state'] = {};
          }
          target = target['state'];
          target['error'] = null;
          var init = { method: 'GET' };
          if (controller && typeof controller.signal !== 'undefined') {
            init.signal = controller.signal;
          }
          var execute = async function () {
            try {
              const response = await fetch('https://example.com/demo-quote.json', init);
              if (!response.ok) {
                throw new Error('Request failed with status ' + response.status);
              }
              const data = await response.json();
              if (!owner) {
                return;
              }
              var target = owner;
              if (target['state'] == null || typeof target['state'] !== 'object') {
                target['state'] = {};
              }
              target = target['state'];
              target['quote'] = data;
              if (!owner) {
                return;
              }
              var target = owner;
              if (target['state'] == null || typeof target['state'] !== 'object') {
                target['state'] = {};
              }
              target = target['state'];
              target['error'] = null;
            } catch (error) {
              if (!owner) {
                return;
              }
              var target = owner;
              if (target['state'] == null || typeof target['state'] !== 'object') {
                target['state'] = {};
              }
              target = target['state'];
              target['error'] = error instanceof Error && error.message ? error.message : String(error);
              console.error('FETCH request failed:', error);
            } finally {
              if (!owner) {
                return;
              }
              var target = owner;
              if (target['state'] == null || typeof target['state'] !== 'object') {
                target['state'] = {};
              }
              target = target['state'];
              target['loading'] = false;
              if (runtime) {
                runtime.notify();
              }
              if (owner && typeof owner.render === 'function') {
                owner.render();
              }
            }
          };
          execute();
          return function () {
            if (controller && typeof controller.abort === 'function') {
              controller.abort();
            }
          };
        }
      });
    }(this));
    (function () {
      if (typeof window === 'undefined')
        return;
      if (!window.__htms) {
        const runtime = {
          watchers: [],
          effects: [],
          flushScheduled: false,
          scheduleFlush: function () {
            if (this.flushScheduled) {
              return;
            }
            this.flushScheduled = true;
            const runFlush = () => {
              this.flushScheduled = false;
              try {
                this.flush();
              } catch (error) {
                console.error('HTMS runtime flush failed:', error);
              }
            };
            if (typeof queueMicrotask === 'function') {
              queueMicrotask(runFlush);
            } else {
              Promise.resolve().then(runFlush);
            }
          },
          flush: function () {
            this.watchers = this.watchers.filter(function (watcher) {
              if (watcher.disposed) {
                return false;
              }
              try {
                const el = document.querySelector(watcher.sel);
                if (!el) {
                  if (watcher.autoDispose) {
                    watcher.disposed = true;
                    return false;
                  }
                  return true;
                }
                el[watcher.prop] = watcher.fn();
              } catch (error) {
                console.error('HTMS watcher update failed:', error);
              }
              return !watcher.disposed;
            });
            this.effects = this.effects.filter(effect => {
              if (effect.disposed) {
                return false;
              }
              if (effect.owner && !effect.owner.isConnected) {
                effect.dispose();
                return false;
              }
              const values = [];
              let shouldRun = effect.dirty || effect.depsFns.length === 0;
              for (let i = 0; i < effect.depsFns.length; i++) {
                let value;
                try {
                  value = effect.depsFns[i]();
                } catch (error) {
                  console.error('HTMS effect dependency failed:', error);
                  value = undefined;
                }
                values.push(value);
                if (!shouldRun && (i >= effect.lastValues.length || effect.lastValues[i] !== value)) {
                  shouldRun = true;
                }
              }
              effect.lastValues = values;
              if (effect.skipInitial && !effect.initialized) {
                effect.skipInitial = false;
                effect.dirty = false;
                effect.initialized = true;
                return !effect.disposed;
              }
              if (shouldRun) {
                effect.dirty = false;
                effect.execute();
                effect.initialized = true;
                if (effect.once) {
                  effect.dispose();
                  return false;
                }
              }
              return !effect.disposed;
            });
          },
          bind: function (sel, prop, fn) {
            const watcher = {
              sel,
              prop,
              fn,
              disposed: false,
              autoDispose: true
            };
            this.watchers.push(watcher);
            try {
              const el = document.querySelector(sel);
              if (!el) {
                console.warn('BIND target not found:', sel);
              } else {
                el[prop] = fn();
              }
            } catch (error) {
              console.error('BIND compute failed:', error);
            }
            return () => {
              watcher.disposed = true;
            };
          },
          notify: function () {
            this.scheduleFlush();
          },
          registerEffect: function (spec) {
            if (!spec || !spec.id) {
              console.error('HTMS effect requires an id');
              return {
                dispose: function () {
                }
              };
            }
            const owner = spec.owner || null;
            const deps = Array.isArray(spec.deps) ? spec.deps.filter(fn => typeof fn === 'function') : [];
            let record = this.effects.find(effect => effect.owner === owner && effect.id === spec.id);
            if (!record) {
              record = {
                owner,
                id: spec.id,
                depsFns: deps,
                run: typeof spec.run === 'function' ? spec.run : function () {
                },
                cleanupFactory: typeof spec.cleanup === 'function' ? spec.cleanup : undefined,
                cleanup: undefined,
                lastValues: [],
                disposed: false,
                dirty: spec.immediate !== false,
                once: !!spec.once,
                initialized: false,
                skipInitial: spec.immediate === false,
                dispose: function () {
                  if (record.disposed) {
                    return;
                  }
                  record.disposed = true;
                  if (typeof record.cleanup === 'function') {
                    try {
                      record.cleanup();
                    } catch (error) {
                      console.error('HTMS effect cleanup failed:', error);
                    }
                  }
                  record.cleanup = undefined;
                  record.initialized = false;
                  record.skipInitial = false;
                },
                execute: function () {
                  if (record.disposed) {
                    return;
                  }
                  if (typeof record.cleanup === 'function') {
                    try {
                      record.cleanup();
                    } catch (error) {
                      console.error('HTMS effect cleanup failed:', error);
                    }
                    record.cleanup = undefined;
                  }
                  let nextCleanup = record.cleanupFactory;
                  try {
                    const result = record.run();
                    if (result && typeof result.then === 'function') {
                      record.initialized = true;
                      result.then(resolved => {
                        if (typeof resolved === 'function') {
                          record.cleanup = resolved;
                        } else if (typeof nextCleanup === 'function') {
                          record.cleanup = nextCleanup;
                        }
                      }).catch(error => {
                        console.error('HTMS effect promise rejected:', error);
                      });
                      return;
                    }
                    if (typeof result === 'function') {
                      nextCleanup = result;
                    }
                  } catch (error) {
                    console.error('HTMS effect execution failed:', error);
                  }
                  record.cleanup = typeof nextCleanup === 'function' ? nextCleanup : undefined;
                  record.initialized = true;
                }
              };
              this.effects.push(record);
            } else {
              record.depsFns = deps;
              record.run = typeof spec.run === 'function' ? spec.run : record.run;
              record.cleanupFactory = typeof spec.cleanup === 'function' ? spec.cleanup : record.cleanupFactory;
              record.once = !!spec.once;
              record.disposed = false;
              if (spec.immediate !== false && !record.initialized) {
                record.dirty = true;
              }
              if (spec.immediate === false && !record.initialized) {
                record.skipInitial = true;
              } else if (spec.immediate !== false) {
                record.skipInitial = false;
              }
            }
            this.scheduleFlush();
            return {
              dispose: function () {
                record.dispose();
              }
            };
          },
          keyedList: function (sel, arr, render, keyFn) {
            const container = document.querySelector(sel);
            if (!container) {
              console.warn('KEYEDLIST target not found:', sel);
              return;
            }
            const existing = new Map();
            Array.from(container.children).forEach(function (node) {
              if (node && typeof node.getAttribute === 'function') {
                const key = node.getAttribute('data-key');
                if (key != null) {
                  existing.set(key, node);
                }
              }
            });
            const used = new Set();
            for (let i = 0; i < arr.length; i++) {
              const item = arr[i];
              const key = String(keyFn(item, i));
              let node = existing.get(key);
              if (!node) {
                node = render(item, i);
                if (node && typeof node.setAttribute === 'function') {
                  node.setAttribute('data-key', key);
                }
              }
              if (node) {
                container.appendChild(node);
                used.add(key);
              }
            }
            existing.forEach(function (node, key) {
              if (!used.has(key) && node && node.parentNode === container) {
                container.removeChild(node);
              }
            });
          },
          disposeEffectsFor: function (owner) {
            if (!owner) {
              return;
            }
            this.effects = this.effects.filter(effect => {
              if (effect.owner === owner) {
                effect.dispose();
                return false;
              }
              return true;
            });
          }
        };
        Object.defineProperty(window, '__htms', {
          value: runtime,
          configurable: false,
          enumerable: false,
          writable: false
        });
      }
    }());
    (function (owner) {
      var runtime = typeof window !== 'undefined' ? window.__htms : null;
      if (!runtime) {
        return;
      }
      runtime.registerEffect({
        owner: owner,
        id: '__effect_2',
        deps: [
          function () {
            return owner && owner.state && owner.state.loading;
          },
          function () {
            return owner && owner.state && owner.state.quote;
          },
          function () {
            return owner && owner.state && owner.state.error;
          }
        ],
        immediate: true,
        once: false,
        run: function () {
          try {
            if (!owner || typeof owner.__htmsSetState !== 'function') {
              return;
            }
            const state = owner.state || {};
            const finished = !state.loading && (state.quote || state.error);
            if (finished && state.loadNonce) {
              owner.__htmsSetState([
                'state',
                'loadNonce'
              ], '=', () => null);
            }
          } catch (error) {
            console.error('EFFECT run failed:', error);
          }
        }
      });
    }(this));
  }
}
customElements.define('effect-fetch-demo', EffectFetchDemoComponent);
export {
  EffectFetchDemoComponent
};