// Generated by HTMS - ESM format
'use strict';

class CounterBoxComponent extends HTMLElement {
  static get __htmsTemplate() {
    if (!this.__templateCache) {
      const template = document.createElement('template');
      template.innerHTML = '<div id="count" class="count"></div><button id="increment">Increment</button>';
      this.__templateCache = template;
    }
    return this.__templateCache;
  }
  __htmsResolvePath(path) {
    if (!Array.isArray(path) || path.length === 0) {
      throw new Error('Invalid state path');
    }
    let ref = this;
    for (let i = 0; i < path.length - 1; i++) {
      const key = path[i];
      const next = ref[key];
      if (next === undefined || next === null || typeof next !== 'object') {
        ref[key] = {};
      }
      ref = ref[key];
    }
    return {
      target: ref,
      key: path[path.length - 1]
    };
  }
  __htmsInitState(path, initializer) {
    const {target, key} = this.__htmsResolvePath(path);
    if (!Object.prototype.hasOwnProperty.call(target, key)) {
      target[key] = initializer();
    }
  }
  __htmsSetState(path, op, valueFactory) {
    const {target, key} = this.__htmsResolvePath(path);
    if (op === '++') {
      const current = typeof target[key] === 'number' ? target[key] : 0;
      target[key] = current + 1;
      return;
    }
    if (op === '--') {
      const current = typeof target[key] === 'number' ? target[key] : 0;
      target[key] = current - 1;
      return;
    }
    const current = target[key];
    const value = valueFactory();
    switch (op) {
    case '+=':
      target[key] = (typeof current === 'number' ? current : 0) + value;
      break;
    case '-=':
      target[key] = (typeof current === 'number' ? current : 0) - value;
      break;
    case '*=':
      target[key] = (typeof current === 'number' ? current : 0) * value;
      break;
    case '/=':
      target[key] = (typeof current === 'number' ? current : 0) / value;
      break;
    default:
      target[key] = value;
    }
  }
  __htmsEnsureArray(path) {
    const {target, key} = this.__htmsResolvePath(path);
    if (!Array.isArray(target[key])) {
      target[key] = [];
    }
    return target[key];
  }
  __htmsPushState(path, valueFactory) {
    const arr = this.__htmsEnsureArray(path);
    arr.push(valueFactory());
  }
  __htmsSpliceState(path, indexFactory, deleteFactory, valuesFactory) {
    const arr = this.__htmsEnsureArray(path);
    const index = indexFactory();
    const del = deleteFactory();
    const values = valuesFactory();
    arr.splice(index, del, ...values);
  }
  constructor() {
    super();
    this.__htmsRoot = null;
    if (!this.__htmsRoot) {
      this.__htmsRoot = this.attachShadow({ mode: 'open' });
    }
  }
  connectedCallback() {
    this.render();
  }
  render() {
    const root = this.__htmsRoot || this;
    if (!root) {
      throw new Error('Component root not initialized');
    }
    const componentRoot = root;
    while (componentRoot.firstChild) {
      componentRoot.removeChild(componentRoot.firstChild);
    }
    const staticFragment = CounterBoxComponent.__htmsTemplate.content.cloneNode(true);
    componentRoot.appendChild(staticFragment);
    this.__htmsInitState(['count'], () => 0);
    {
      const eventTargets = componentRoot.querySelectorAll('#increment');
      eventTargets.forEach(targetEl => {
        const _handler0 = event => {
          // No event body
          this.__htmsSetState(['count'], '++', () => undefined);
          this.render();
        };
        targetEl.addEventListener('click', _handler0);
      });
    }
    {
      const nodes = componentRoot.querySelectorAll('#count');
      nodes.forEach(node => {
        try {
          const value = function () {
            return String(this.count);
          }.call(this);
          node['textContent'] = value;
        } catch (error) {
          console.error('BIND evaluation failed for #count', error);
        }
      });
    }
  }
}
customElements.define('counter-box', CounterBoxComponent);
export {
  CounterBoxComponent
};